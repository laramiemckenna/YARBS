// src/utils/fileParser.js

/**
 * Parse coordinate files generated by minimap_prep.py
 * @param {string} coordsText - Content of .coords file
 * @param {string} idxText - Content of .coords.idx file
 * @returns {Object} Parsed data with alignments, references, and queries
 */
export const parseCoordinateFiles = (coordsText, idxText) => {
  console.log('Starting to parse coordinate files...');
  
  const alignments = parseAlignments(coordsText);
  const { references, queries } = parseIndex(idxText);
  
  // Validate the parsed data
  validateParsedData(alignments, references, queries);
  
  console.log(`Successfully parsed:
    - ${alignments.length} alignments
    - ${references.length} references  
    - ${queries.length} queries`);
  
  return { alignments, references, queries };
};

/**
 * Parse alignment data from coords file
 * @param {string} coordsText - Content of .coords file
 * @returns {Array} Array of alignment objects
 */
const parseAlignments = (coordsText) => {
  const lines = coordsText.split('\n');
  const alignments = [];
  let currentQuery = '';
  let currentTag = '';
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    if (!line) continue;
    
    if (line.startsWith('!')) {
      // Parse query section header: !query_name!tag
      const parts = line.slice(1).split('!');
      currentQuery = parts[0] || '';
      currentTag = parts[1] || 'unique';
      
      if (!currentQuery) {
        console.warn(`Empty query name at line ${i + 1}: ${line}`);
        continue;
      }
    } else if (line.startsWith('ref_start')) {
      // Skip header line
      continue;
    } else if (line.includes(',')) {
      // Parse alignment data
      // Format: ref_start,ref_end,query_start,query_end,ref,original_orientation,aligned_orientation,needs_flip,identity
      const fields = line.split(',').map(field => field.trim());

      if (fields.length >= 5) {
        try {
          const alignment = {
            refStart: parseInt(fields[0]),
            refEnd: parseInt(fields[1]),
            queryStart: parseInt(fields[2]),
            queryEnd: parseInt(fields[3]),
            ref: fields[4],
            query: currentQuery,
            tag: currentTag,
            length: Math.abs(parseInt(fields[1]) - parseInt(fields[0])),
            queryLength: Math.abs(parseInt(fields[3]) - parseInt(fields[2])),
            // Parse orientation metadata if available (new format from minimap_prep.py)
            originalOrientation: fields[5] || '+',
            alignedOrientation: fields[6] || '+',
            needsFlip: fields[7] === 'True' || fields[7] === 'true',
            identity: fields[8] ? parseFloat(fields[8]) : Math.min(95, 70 + Math.random() * 25)
          };

          // Validate alignment data
          if (isValidAlignment(alignment)) {
            alignments.push(alignment);
          } else {
            console.warn(`Invalid alignment at line ${i + 1}:`, alignment);
          }
        } catch (error) {
          console.warn(`Error parsing alignment at line ${i + 1}: ${line}`, error);
        }
      } else {
        console.warn(`Insufficient fields at line ${i + 1}: ${line}`);
      }
    }
  }
  
  return alignments;
};

/**
 * Parse index file to extract reference and query information
 * @param {string} idxText - Content of .coords.idx file
 * @returns {Object} Object with references and queries arrays
 */
const parseIndex = (idxText) => {
  const lines = idxText.split('\n');
  const references = [];
  const queries = [];
  let currentSection = '';
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    if (!line) continue;
    
    if (line.startsWith('#')) {
      currentSection = line.slice(1);
      continue;
    }
    
    if (currentSection === 'ref') {
      if (line.startsWith('ref,')) continue; // Skip header
      
      const fields = line.split(',');
      if (fields.length >= 2) {
        const reference = {
          name: fields[0].trim(),
          length: parseInt(fields[1]),
          matchingQueries: fields[2] ? fields[2].split('~').map(q => q.trim()) : []
        };
        
        if (reference.name && !isNaN(reference.length)) {
          references.push(reference);
        }
      }
    } else if (currentSection === 'query') {
      if (line.startsWith('query,')) continue; // Skip header

      const fields = line.split(',');
      if (fields.length >= 2) {
        const query = {
          name: fields[0].trim(),
          length: parseInt(fields[1]),
          orientation: fields[2] || '+',
          uniqueAlignments: parseInt(fields[3]) || 0,
          uniqueShortAlignments: parseInt(fields[4]) || 0,
          repetitiveAlignments: parseInt(fields[5]) || 0,
          matchingRefs: fields[6] ? fields[6].split('~').map(r => r.trim()) : []
        };

        if (query.name && !isNaN(query.length)) {
          queries.push(query);
        }
      }
    }
    // Skip overview section for now - we don't need it for basic visualization
  }
  
  return { references, queries };
};

/**
 * Validate that an alignment object has required fields
 * @param {Object} alignment - Alignment object to validate
 * @returns {boolean} True if valid
 */
const isValidAlignment = (alignment) => {
  const required = ['refStart', 'refEnd', 'queryStart', 'queryEnd', 'ref', 'query'];
  
  for (const field of required) {
    if (alignment[field] === undefined || alignment[field] === null) {
      return false;
    }
  }
  
  // Check that coordinates are numbers and make sense
  const coords = [alignment.refStart, alignment.refEnd, alignment.queryStart, alignment.queryEnd];
  if (coords.some(coord => isNaN(coord) || coord < 0)) {
    return false;
  }
  
  // Check that start <= end (allowing for reverse alignments)
  if (alignment.refStart === alignment.refEnd || alignment.queryStart === alignment.queryEnd) {
    return false;
  }
  
  return true;
};

/**
 * Validate the overall parsed data structure
 * @param {Array} alignments - Parsed alignments
 * @param {Array} references - Parsed references  
 * @param {Array} queries - Parsed queries
 * @throws {Error} If data is invalid
 */
const validateParsedData = (alignments, references, queries) => {
  if (!Array.isArray(alignments)) {
    throw new Error('Alignments must be an array');
  }
  
  if (!Array.isArray(references)) {
    throw new Error('References must be an array');
  }
  
  if (!Array.isArray(queries)) {
    throw new Error('Queries must be an array');
  }
  
  if (alignments.length === 0) {
    throw new Error('No alignments found in coordinate file');
  }
  
  if (references.length === 0) {
    throw new Error('No references found in index file');
  }
  
  if (queries.length === 0) {
    throw new Error('No queries found in index file');
  }
  
  // Check that alignment references exist in reference list
  const refNames = new Set(references.map(r => r.name));
  const queryNames = new Set(queries.map(q => q.name));
  
  const missingRefs = new Set();
  const missingQueries = new Set();
  
  alignments.forEach(alignment => {
    if (!refNames.has(alignment.ref)) {
      missingRefs.add(alignment.ref);
    }
    if (!queryNames.has(alignment.query)) {
      missingQueries.add(alignment.query);
    }
  });
  
  if (missingRefs.size > 0) {
    console.warn('Alignments reference unknown references:', Array.from(missingRefs));
  }
  
  if (missingQueries.size > 0) {
    console.warn('Alignments reference unknown queries:', Array.from(missingQueries));
  }
};

/**
 * Get statistics about the parsed data
 * @param {Object} data - Parsed data object
 * @returns {Object} Statistics object
 */
export const getDataStatistics = (data) => {
  if (!data || !data.alignments) {
    return {};
  }

  const uniqueAlignments = data.alignments.filter(a => a.tag === 'unique');
  const uniqueShortAlignments = data.alignments.filter(a => a.tag === 'unique_short');
  const repetitiveAlignments = data.alignments.filter(a => a.tag === 'repetitive');

  const totalRefLength = data.references.reduce((sum, ref) => sum + ref.length, 0);
  const totalQueryLength = data.queries.reduce((sum, query) => sum + query.length, 0);

  const alignmentLengths = data.alignments.map(a => a.length);
  const avgAlignmentLength = alignmentLengths.reduce((sum, len) => sum + len, 0) / alignmentLengths.length;

  return {
    totalAlignments: data.alignments.length,
    uniqueAlignments: uniqueAlignments.length,
    uniqueShortAlignments: uniqueShortAlignments.length,
    repetitiveAlignments: repetitiveAlignments.length,
    totalReferences: data.references.length,
    totalQueries: data.queries.length,
    totalRefLength,
    totalQueryLength,
    avgAlignmentLength: Math.round(avgAlignmentLength),
    alignmentsByReference: getAlignmentsByReference(data.alignments),
    alignmentsByQuery: getAlignmentsByQuery(data.alignments)
  };
};

/**
 * Group alignments by reference
 */
const getAlignmentsByReference = (alignments) => {
  const grouped = {};
  alignments.forEach(alignment => {
    if (!grouped[alignment.ref]) {
      grouped[alignment.ref] = [];
    }
    grouped[alignment.ref].push(alignment);
  });
  return grouped;
};

/**
 * Group alignments by query
 */
const getAlignmentsByQuery = (alignments) => {
  const grouped = {};
  alignments.forEach(alignment => {
    if (!grouped[alignment.query]) {
      grouped[alignment.query] = [];
    }
    grouped[alignment.query].push(alignment);
  });
  return grouped;
};
